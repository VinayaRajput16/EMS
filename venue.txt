// venueController
import { venueService } from "./venueService.js";

export const venueController = {
  async create(req, res, next) {
    try {
      const venue = await venueService.create(req.body, req.user.id);
      res.status(201).json({ success: true, data: venue });
    } catch (e) {
      next(e);
    }
  },

  async list(req, res, next) {
    try {
      const venues = await venueService.getAll(req.user);
      res.json({ success: true, data: venues });
    } catch (e) {
      next(e);
    }
  },

  async getById(req, res, next) {
    try {
      const venue = await venueService.getById(req.params.id, req.user);
      res.json({ success: true, data: venue });
    } catch (e) {
      next(e);
    }
  },

  async update(req, res, next) {
    try {
      const venue = await venueService.update(
        req.params.id,
        req.body,
        req.user
      );
      res.json({ success: true, data: venue });
    } catch (e) {
      next(e);
    }
  },

  async remove(req, res, next) {
    try {
      await venueService.remove(req.params.id, req.user);
      res.json({ success: true, message: "Venue deleted" });
    } catch (e) {
      next(e);
    }
  },
};
// venueRepo.js
import  prisma  from "../../config/db.js"

export const venueRepo = {
  create(data) {
    return prisma.venue.create({ data });
  },

  findById(id) {
    return prisma.venue.findUnique({
      where: { id },
      include: {
        organizer: {
          select: { id: true, name: true, email: true },
        },
      },
    });
  },

  findAll() {
    return prisma.venue.findMany({
      include: {
        organizer: {
          select: { id: true, name: true, email: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });
  },

  findByOrganizer(organizerId) {
    return prisma.venue.findMany({
      where: { organizerId },
      include: {
        organizer: {
          select: { id: true, name: true, email: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });
  },

  updateById(id, data) {
    return prisma.venue.update({
      where: { id },
      data,
      include: {
        organizer: {
          select: { id: true, name: true, email: true },
        },
      },
    });
  },

  deleteById(id) {
    return prisma.venue.delete({
      where: { id },
    });
  },

  countPublishedEventsUsingVenue(id) {
    return prisma.event.count({
      where: {
        venueId: id,
        status: "PUBLISHED",
      },
    });
  },
};
// venueRoutes.js
import { Router } from "express";
import { venueController } from "./venueController.js";
import { authMiddleware } from "../../common/middleware/authMiddleware.js";
import { requireRole } from "../../common/middleware/roleMiddleware.js";

const venueRouter = Router();

// Create venue (organizer only)
venueRouter.post(
  "/venues",
  authMiddleware,
  requireRole("ORGANIZER"),
  venueController.create
);

// List venues (role-aware, but all authenticated roles can read)
venueRouter.get(
  "/venues",
  authMiddleware,
  requireRole("ADMIN", "ORGANIZER", "USER"),
  venueController.list
);

// Get venue by id
venueRouter.get(
  "/venues/:id",
  authMiddleware,
  requireRole("ADMIN", "ORGANIZER", "USER"),
  venueController.getById
);

// Update venue (organizer only, own venues)
venueRouter.patch(
  "/venues/:id",
  authMiddleware,
  requireRole("ORGANIZER"),
  venueController.update
);

// Delete venue (organizer only, own venues)
venueRouter.delete(
  "/venues/:id",
  authMiddleware,
  requireRole("ORGANIZER"),
  venueController.remove
);

export default venueRouter;
// venueService 
import AppError from "../../common/errors/AppError.js";
import { venueRepo } from "./venueRepo.js";

export const venueService = {
  async create(payload, organizerId) {
    const { name, location, capacity } = payload;

    if (!name || !location || capacity === undefined) {
      throw new AppError("Missing required fields", 400);
    }

    if (capacity <= 0) {
      throw new AppError("Capacity must be greater than 0", 400);
    }

    return venueRepo.create({
      name,
      location,
      capacity,
      organizerId,
    });
  },

  async getAll(user) {
    if (user.role === "ADMIN") {
      return venueRepo.findAll();
    }

    // USER and ORGANIZER both get read-only list
    if (user.role === "ORGANIZER") {
      return venueRepo.findByOrganizer(user.id);
    }

    // Normal user: see all venues (read-only)
    return venueRepo.findAll();
  },

  async getById(id, user) {
    const venue = await venueRepo.findById(id);
    if (!venue) throw new AppError("Venue not found", 404);

    // Everyone can read single venue
    return venue;
  },

  async update(id, payload, user) {
    const venue = await venueRepo.findById(id);
    if (!venue) throw new AppError("Venue not found", 404);

    if (user.role !== "ORGANIZER") {
      throw new AppError("Unauthorized", 403);
    }

    if (venue.organizerId !== user.id) {
      throw new AppError("Unauthorized", 403);
    }

    const updateData = {};

    if (payload.name !== undefined) updateData.name = payload.name;
    if (payload.location !== undefined) updateData.location = payload.location;

    if (payload.capacity !== undefined) {
      if (payload.capacity <= 0) {
        throw new AppError("Capacity must be greater than 0", 400);
      }
      updateData.capacity = payload.capacity;
    }

    return venueRepo.updateById(id, updateData);
  },

  async remove(id, user) {
    const venue = await venueRepo.findById(id);
    if (!venue) throw new AppError("Venue not found", 404);

    if (user.role !== "ORGANIZER") {
      throw new AppError("Unauthorized", 403);
    }

    if (venue.organizerId !== user.id) {
      throw new AppError("Unauthorized", 403);
    }

    const linkedPublished = await venueRepo.countPublishedEventsUsingVenue(id);
    if (linkedPublished > 0) {
      throw new AppError(
        "Cannot delete venue linked to published events",
        400
      );
    }

    await venueRepo.deleteById(id);
  },
};
